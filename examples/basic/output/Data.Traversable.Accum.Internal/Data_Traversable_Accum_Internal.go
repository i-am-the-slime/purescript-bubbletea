// Code generated by psgo. DO NOT EDIT.

package Data_Traversable_Accum_Internal

import . "github.com/purescript-native/go-runtime"

import (
)

type _ = Any

func ꞋStateR() Any {
    return func(x Any) Any {
        return x
    }
}
func ꞋStateL() Any {
    return func(x Any) Any {
        return x
    }
}
func ꞋstateR() Any {
    return func(v Any) Any {
        return v
    }
}
func ꞋstateL() Any {
    return func(v Any) Any {
        return v
    }
}

var ᛌfunctorStateR_once Once
var ᛧfunctorStateR Any

func ꞋfunctorStateR() Any {
    ᛌfunctorStateR_once.Do(func() {
        ᛧfunctorStateR = Dict{"map": func(f Any) Any {
            return func(k Any) Any {
                return func(s Any) Any {
                    var v Any = Apply(ꞋstateR(), k, s)
                    return Dict{"accum": v.(Dict)["accum"], "value": Apply(f, v.(Dict)["value"]),}
                }
            }
        },}
    })
return ᛧfunctorStateR
}



var ᛌfunctorStateL_once Once
var ᛧfunctorStateL Any

func ꞋfunctorStateL() Any {
    ᛌfunctorStateL_once.Do(func() {
        ᛧfunctorStateL = Dict{"map": func(f Any) Any {
            return func(k Any) Any {
                return func(s Any) Any {
                    var v Any = Apply(ꞋstateL(), k, s)
                    return Dict{"accum": v.(Dict)["accum"], "value": Apply(f, v.(Dict)["value"]),}
                }
            }
        },}
    })
return ᛧfunctorStateL
}



var ᛌapplyStateR_once Once
var ᛧapplyStateR Any

func ꞋapplyStateR() Any {
    ᛌapplyStateR_once.Do(func() {
        ᛧapplyStateR = Dict{"apply": func(f Any) Any {
            return func(x Any) Any {
                return func(s Any) Any {
                    var v Any = Apply(ꞋstateR(), x, s)
                    var v1 Any = Apply(ꞋstateR(), f, v.(Dict)["accum"])
                    return Dict{"accum": v1.(Dict)["accum"], "value": Apply(v1.(Dict)["value"], v.(Dict)["value"]),}
                }
            }
        }, "Functor0": func(_ Any) Any {
            return ꞋfunctorStateR()
        },}
    })
return ᛧapplyStateR
}



var ᛌapplyStateL_once Once
var ᛧapplyStateL Any

func ꞋapplyStateL() Any {
    ᛌapplyStateL_once.Do(func() {
        ᛧapplyStateL = Dict{"apply": func(f Any) Any {
            return func(x Any) Any {
                return func(s Any) Any {
                    var v Any = Apply(ꞋstateL(), f, s)
                    var v1 Any = Apply(ꞋstateL(), x, v.(Dict)["accum"])
                    return Dict{"accum": v1.(Dict)["accum"], "value": Apply(v.(Dict)["value"], v1.(Dict)["value"]),}
                }
            }
        }, "Functor0": func(_ Any) Any {
            return ꞋfunctorStateL()
        },}
    })
return ᛧapplyStateL
}



var ᛌapplicativeStateR_once Once
var ᛧapplicativeStateR Any

func ꞋapplicativeStateR() Any {
    ᛌapplicativeStateR_once.Do(func() {
        ᛧapplicativeStateR = Dict{"pure": func(a Any) Any {
            return func(s Any) Any {
                return Dict{"accum": s, "value": a,}
            }
        }, "Apply0": func(_ Any) Any {
            return ꞋapplyStateR()
        },}
    })
return ᛧapplicativeStateR
}



var ᛌapplicativeStateL_once Once
var ᛧapplicativeStateL Any

func ꞋapplicativeStateL() Any {
    ᛌapplicativeStateL_once.Do(func() {
        ᛧapplicativeStateL = Dict{"pure": func(a Any) Any {
            return func(s Any) Any {
                return Dict{"accum": s, "value": a,}
            }
        }, "Apply0": func(_ Any) Any {
            return ꞋapplyStateL()
        },}
    })
return ᛧapplicativeStateL
}





