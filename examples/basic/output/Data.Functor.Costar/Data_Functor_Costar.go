// Code generated by psgo. DO NOT EDIT.

package Data_Functor_Costar

import . "github.com/purescript-native/go-runtime"

import (
	"project.localhost/purescript-native/output/Control.Semigroupoid"
	"project.localhost/purescript-native/output/Data.Profunctor"
	"project.localhost/purescript-native/output/Control.Extend"
	"project.localhost/purescript-native/output/Data.Functor"
	"project.localhost/purescript-native/output/Control.Comonad"
	"project.localhost/purescript-native/output/Data.Tuple"
	"project.localhost/purescript-native/output/Data.Functor.Invariant"
	"project.localhost/purescript-native/output/Data.Distributive"
	"project.localhost/purescript-native/output/Data.Functor.Contravariant"
)

type _ = Any

func ꞋcomposeFlipped() Any {
    return Apply(Control_Semigroupoid.ꞋcomposeFlipped(), Control_Semigroupoid.ꞋsemigroupoidFn())
}
func Ꞌlcmap() Any {
    return Apply(Data_Profunctor.Ꞌlcmap(), Data_Profunctor.ꞋprofunctorFn())
}
func Ꞌcompose() Any {
    return Apply(Control_Semigroupoid.Ꞌcompose(), Control_Semigroupoid.ꞋsemigroupoidFn())
}
func ꞋCostar() Any {
    return func(x Any) Any {
        return x
    }
}
func ꞋsemigroupoidCostar() Any {
    return func(dictExtend Any) Any {
        var composeCoKleisliFlipped Any = Apply(Control_Extend.ꞋcomposeCoKleisliFlipped(), dictExtend)
        return Dict{"compose": func(v Any) Any {
                return func(v1 Any) Any {
                    return Apply(composeCoKleisliFlipped, v, v1)
                }
            },}
    }
}
func ꞋprofunctorCostar() Any {
    return func(dictFunctor Any) Any {
        var ˉmap Any = Apply(Data_Functor.Ꞌmap(), dictFunctor)
        return Dict{"dimap": func(f Any) Any {
                return func(g Any) Any {
                    return func(v Any) Any {
                        return Apply(ꞋcomposeFlipped(), Apply(ˉmap, f), Apply(ꞋcomposeFlipped(), v, g))
                    }
                }
            },}
    }
}
func ꞋstrongCostar() Any {
    return func(dictComonad Any) Any {
        var Functor0 Any = Apply(Apply(dictComonad.(Dict)["Extend0"], Undefined).(Dict)["Functor0"], Undefined)
        var ˉmap Any = Apply(Data_Functor.Ꞌmap(), Functor0)
        var extract Any = Apply(Control_Comonad.Ꞌextract(), dictComonad)
        var profunctorCostar1 Any = Apply(ꞋprofunctorCostar(), Functor0)
        return Dict{"first": func(v Any) Any {
                return func(x Any) Any {
                    return Apply(Data_Tuple.ꞋTuple(), Apply(v, Apply(ˉmap, Data_Tuple.Ꞌfst(), x)), Apply(Data_Tuple.Ꞌsnd(), Apply(extract, x)))
                }
            }, "second": func(v Any) Any {
                return func(x Any) Any {
                    return Apply(Data_Tuple.ꞋTuple(), Apply(Data_Tuple.Ꞌfst(), Apply(extract, x)), Apply(v, Apply(ˉmap, Data_Tuple.Ꞌsnd(), x)))
                }
            }, "Profunctor0": func(_ Any) Any {
                return profunctorCostar1
            },}
    }
}

var ᛌnewtypeCostar_once Once
var ᛧnewtypeCostar Any

func ꞋnewtypeCostar() Any {
    ᛌnewtypeCostar_once.Do(func() {
        ᛧnewtypeCostar = Dict{"Coercible0": func(_ Any) Any {
            return Undefined
        },}
    })
return ᛧnewtypeCostar
}


func ꞋhoistCostar() Any {
    return func(f Any) Any {
        return func(v Any) Any {
            return Apply(Ꞌlcmap(), f, v)
        }
    }
}

var ᛌfunctorCostar_once Once
var ᛧfunctorCostar Any

func ꞋfunctorCostar() Any {
    ᛌfunctorCostar_once.Do(func() {
        ᛧfunctorCostar = Dict{"map": func(f Any) Any {
            return func(v Any) Any {
                return Apply(Ꞌcompose(), f, v)
            }
        },}
    })
return ᛧfunctorCostar
}



var ᛌinvariantCostar_once Once
var ᛧinvariantCostar Any

func ꞋinvariantCostar() Any {
    ᛌinvariantCostar_once.Do(func() {
        ᛧinvariantCostar = Dict{"imap": Apply(Data_Functor_Invariant.ꞋimapF(), ꞋfunctorCostar()),}
    })
return ᛧinvariantCostar
}



var ᛌdistributiveCostar_once Once
var ᛧdistributiveCostar Any

func ꞋdistributiveCostar() Any {
    ᛌdistributiveCostar_once.Do(func() {
        ᛧdistributiveCostar = Dict{"distribute": func(dictFunctor Any) Any {
            var ˉmap Any = Apply(Data_Functor.Ꞌmap(), dictFunctor)
            return func(f Any) Any {
                return func(a Any) Any {
                    return Apply(ˉmap, func(v Any) Any {
                        return Apply(v, a)
                    }, f)
                }
            }
        }, "collect": func(dictFunctor Any) Any {
            var ˉmap Any = Apply(Data_Functor.Ꞌmap(), dictFunctor)
            return func(f Any) Any {
                return Apply(Ꞌcompose(), Apply(Data_Distributive.Ꞌdistribute(), ꞋdistributiveCostar(), dictFunctor), Apply(ˉmap, f))
            }
        }, "Functor0": func(_ Any) Any {
            return ꞋfunctorCostar()
        },}
    })
return ᛧdistributiveCostar
}


func ꞋclosedCostar() Any {
    return func(dictFunctor Any) Any {
        var ˉmap Any = Apply(Data_Functor.Ꞌmap(), dictFunctor)
        var profunctorCostar1 Any = Apply(ꞋprofunctorCostar(), dictFunctor)
        return Dict{"closed": func(v Any) Any {
                return func(g Any) Any {
                    return func(x Any) Any {
                        return Apply(v, Apply(ˉmap, func(v1 Any) Any {
                            return Apply(v1, x)
                        }, g))
                    }
                }
            }, "Profunctor0": func(_ Any) Any {
                return profunctorCostar1
            },}
    }
}
func ꞋcategoryCostar() Any {
    return func(dictComonad Any) Any {
        var semigroupoidCostar1 Any = Apply(ꞋsemigroupoidCostar(), Apply(dictComonad.(Dict)["Extend0"], Undefined))
        return Dict{"identity": Apply(Control_Comonad.Ꞌextract(), dictComonad), "Semigroupoid0": func(_ Any) Any {
                return semigroupoidCostar1
            },}
    }
}
func ꞋbifunctorCostar() Any {
    return func(dictContravariant Any) Any {
        var cmap Any = Apply(Data_Functor_Contravariant.Ꞌcmap(), dictContravariant)
        return Dict{"bimap": func(f Any) Any {
                return func(g Any) Any {
                    return func(v Any) Any {
                        return Apply(ꞋcomposeFlipped(), Apply(cmap, f), Apply(ꞋcomposeFlipped(), v, g))
                    }
                }
            },}
    }
}

var ᛌapplyCostar_once Once
var ᛧapplyCostar Any

func ꞋapplyCostar() Any {
    ᛌapplyCostar_once.Do(func() {
        ᛧapplyCostar = Dict{"apply": func(v Any) Any {
            return func(v1 Any) Any {
                return func(a Any) Any {
                    return Apply(v, a, Apply(v1, a))
                }
            }
        }, "Functor0": func(_ Any) Any {
            return ꞋfunctorCostar()
        },}
    })
return ᛧapplyCostar
}



var ᛌbindCostar_once Once
var ᛧbindCostar Any

func ꞋbindCostar() Any {
    ᛌbindCostar_once.Do(func() {
        ᛧbindCostar = Dict{"bind": func(v Any) Any {
            return func(f Any) Any {
                return func(x Any) Any {
                    var v1 Any = Apply(f, Apply(v, x))
                    return Apply(v1, x)
                }
            }
        }, "Apply0": func(_ Any) Any {
            return ꞋapplyCostar()
        },}
    })
return ᛧbindCostar
}



var ᛌapplicativeCostar_once Once
var ᛧapplicativeCostar Any

func ꞋapplicativeCostar() Any {
    ᛌapplicativeCostar_once.Do(func() {
        ᛧapplicativeCostar = Dict{"pure": func(a Any) Any {
            return func(v Any) Any {
                return a
            }
        }, "Apply0": func(_ Any) Any {
            return ꞋapplyCostar()
        },}
    })
return ᛧapplicativeCostar
}



var ᛌmonadCostar_once Once
var ᛧmonadCostar Any

func ꞋmonadCostar() Any {
    ᛌmonadCostar_once.Do(func() {
        ᛧmonadCostar = Dict{"Applicative0": func(_ Any) Any {
            return ꞋapplicativeCostar()
        }, "Bind1": func(_ Any) Any {
            return ꞋbindCostar()
        },}
    })
return ᛧmonadCostar
}





