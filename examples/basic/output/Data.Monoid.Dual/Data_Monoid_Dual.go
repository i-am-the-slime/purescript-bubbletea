// Code generated by psgo. DO NOT EDIT.

package Data_Monoid_Dual

import . "github.com/purescript-native/go-runtime"

import (
	"project.localhost/purescript-native/output/Data.Semigroup"
	"project.localhost/purescript-native/output/Data.Show"
	"project.localhost/purescript-native/output/Data.Monoid"
	"project.localhost/purescript-native/output/Data.Eq"
	"project.localhost/purescript-native/output/Data.Ord"
)

type _ = Any

func Ꞌappend() Any {
    return Apply(Data_Semigroup.Ꞌappend(), Data_Semigroup.ꞋsemigroupString())
}
func ꞋDual() Any {
    return func(x Any) Any {
        return x
    }
}
func ꞋshowDual() Any {
    return func(dictShow Any) Any {
        var show Any = Apply(Data_Show.Ꞌshow(), dictShow)
        return Dict{"show": func(v Any) Any {
                return Apply(Ꞌappend(), "(Dual ", Apply(Ꞌappend(), Apply(show, v), ")"))
            },}
    }
}
func ꞋsemigroupDual() Any {
    return func(dictSemigroup Any) Any {
        var append1 Any = Apply(Data_Semigroup.Ꞌappend(), dictSemigroup)
        return Dict{"append": func(v Any) Any {
                return func(v1 Any) Any {
                    return Apply(append1, v1, v)
                }
            },}
    }
}
func ꞋordDual() Any {
    return func(dictOrd Any) Any {
        return dictOrd
    }
}
func ꞋmonoidDual() Any {
    return func(dictMonoid Any) Any {
        var semigroupDual1 Any = Apply(ꞋsemigroupDual(), Apply(dictMonoid.(Dict)["Semigroup0"], Undefined))
        return Dict{"mempty": Apply(Data_Monoid.Ꞌmempty(), dictMonoid), "Semigroup0": func(_ Any) Any {
                return semigroupDual1
            },}
    }
}

var ᛌfunctorDual_once Once
var ᛧfunctorDual Any

func ꞋfunctorDual() Any {
    ᛌfunctorDual_once.Do(func() {
        ᛧfunctorDual = Dict{"map": func(f Any) Any {
            return func(m Any) Any {
                return Apply(f, m)
            }
        },}
    })
return ᛧfunctorDual
}


func ꞋeqDual() Any {
    return func(dictEq Any) Any {
        return dictEq
    }
}

var ᛌeq1Dual_once Once
var ᛧeq1Dual Any

func Ꞌeq1Dual() Any {
    ᛌeq1Dual_once.Do(func() {
        ᛧeq1Dual = Dict{"eq1": func(dictEq Any) Any {
            return Apply(Data_Eq.Ꞌeq(), Apply(ꞋeqDual(), dictEq))
        },}
    })
return ᛧeq1Dual
}



var ᛌord1Dual_once Once
var ᛧord1Dual Any

func Ꞌord1Dual() Any {
    ᛌord1Dual_once.Do(func() {
        ᛧord1Dual = Dict{"compare1": func(dictOrd Any) Any {
            return Apply(Data_Ord.Ꞌcompare(), Apply(ꞋordDual(), dictOrd))
        }, "Eq10": func(_ Any) Any {
            return Ꞌeq1Dual()
        },}
    })
return ᛧord1Dual
}


func ꞋboundedDual() Any {
    return func(dictBounded Any) Any {
        return dictBounded
    }
}

var ᛌapplyDual_once Once
var ᛧapplyDual Any

func ꞋapplyDual() Any {
    ᛌapplyDual_once.Do(func() {
        ᛧapplyDual = Dict{"apply": func(v Any) Any {
            return func(v1 Any) Any {
                return Apply(v, v1)
            }
        }, "Functor0": func(_ Any) Any {
            return ꞋfunctorDual()
        },}
    })
return ᛧapplyDual
}



var ᛌbindDual_once Once
var ᛧbindDual Any

func ꞋbindDual() Any {
    ᛌbindDual_once.Do(func() {
        ᛧbindDual = Dict{"bind": func(v Any) Any {
            return func(f Any) Any {
                return Apply(f, v)
            }
        }, "Apply0": func(_ Any) Any {
            return ꞋapplyDual()
        },}
    })
return ᛧbindDual
}



var ᛌapplicativeDual_once Once
var ᛧapplicativeDual Any

func ꞋapplicativeDual() Any {
    ᛌapplicativeDual_once.Do(func() {
        ᛧapplicativeDual = Dict{"pure": ꞋDual(), "Apply0": func(_ Any) Any {
            return ꞋapplyDual()
        },}
    })
return ᛧapplicativeDual
}



var ᛌmonadDual_once Once
var ᛧmonadDual Any

func ꞋmonadDual() Any {
    ᛌmonadDual_once.Do(func() {
        ᛧmonadDual = Dict{"Applicative0": func(_ Any) Any {
            return ꞋapplicativeDual()
        }, "Bind1": func(_ Any) Any {
            return ꞋbindDual()
        },}
    })
return ᛧmonadDual
}





