// Code generated by psgo. DO NOT EDIT.

package Data_Either

import . "github.com/purescript-native/go-runtime"

import (
	"project.localhost/purescript-native/output/Data.Semigroup"
	"project.localhost/purescript-native/output/Control.Semigroupoid"
	"project.localhost/purescript-native/output/Data.Show"
	"project.localhost/purescript-native/output/Data.Maybe"
	"project.localhost/purescript-native/output/Data.Generic.Rep"
	"project.localhost/purescript-native/output/Data.Functor"
	"project.localhost/purescript-native/output/Data.Functor.Invariant"
	"project.localhost/purescript-native/output/Data.Unit"
	"project.localhost/purescript-native/output/Data.Eq"
	"project.localhost/purescript-native/output/Data.Ord"
	"project.localhost/purescript-native/output/Data.Ordering"
	"project.localhost/purescript-native/output/Data.Function"
	"project.localhost/purescript-native/output/Control.Alt"
	"project.localhost/purescript-native/output/Data.Bounded"
	"project.localhost/purescript-native/output/Control.Apply"
)

type _ = Any

func Ꞌappend() Any {
    return Apply(Data_Semigroup.Ꞌappend(), Data_Semigroup.ꞋsemigroupString())
}
func Ꞌcompose() Any {
    return Apply(Control_Semigroupoid.Ꞌcompose(), Control_Semigroupoid.ꞋsemigroupoidFn())
}
func ꞋLeft() Any {
    return func(value0 Any) Any {
        return Dict{"Left": true, "value0": value0,}
    }
}
func ꞋRight() Any {
    return func(value0 Any) Any {
        return Dict{"Right": true, "value0": value0,}
    }
}
func ꞋshowEither() Any {
    return func(dictShow Any) Any {
        var show Any = Apply(Data_Show.Ꞌshow(), dictShow)
        return func(dictShow1 Any) Any {
            var show1 Any = Apply(Data_Show.Ꞌshow(), dictShow1)
            return Dict{"show": func(v Any) Any {
                    if Is(v, "Left") {
                        return Apply(Ꞌappend(), "(Left ", Apply(Ꞌappend(), Apply(show, v.(Dict)["value0"]), ")"))
                    }
                    if Is(v, "Right") {
                        return Apply(Ꞌappend(), "(Right ", Apply(Ꞌappend(), Apply(show1, v.(Dict)["value0"]), ")"))
                    }
                    panic("Failed pattern match at Data.Either (line 173, column 1 - line 175, column 46)")
                },}
        }
    }
}
func Ꞌnoteꞌ() Any {
    return func(f Any) Any {
        return Apply(Data_Maybe.Ꞌmaybeꞌ(), Apply(Ꞌcompose(), ꞋLeft(), f), ꞋRight())
    }
}
func Ꞌnote() Any {
    return func(a Any) Any {
        return Apply(Data_Maybe.Ꞌmaybe(), Apply(ꞋLeft(), a), ꞋRight())
    }
}

var ᛌgenericEither_once Once
var ᛧgenericEither Any

func ꞋgenericEither() Any {
    ᛌgenericEither_once.Do(func() {
        ᛧgenericEither = Dict{"to": func(x Any) Any {
            if Is(x, "Inl") {
                return Apply(ꞋLeft(), x.(Dict)["value0"])
            }
            if Is(x, "Inr") {
                return Apply(ꞋRight(), x.(Dict)["value0"])
            }
            panic("Failed pattern match at Data.Either (line 33, column 1 - line 33, column 56)")
        }, "from": func(x Any) Any {
            if Is(x, "Left") {
                return Apply(Data_Generic_Rep.ꞋInl(), x.(Dict)["value0"])
            }
            if Is(x, "Right") {
                return Apply(Data_Generic_Rep.ꞋInr(), x.(Dict)["value0"])
            }
            panic("Failed pattern match at Data.Either (line 33, column 1 - line 33, column 56)")
        },}
    })
return ᛧgenericEither
}



var ᛌfunctorEither_once Once
var ᛧfunctorEither Any

func ꞋfunctorEither() Any {
    ᛌfunctorEither_once.Do(func() {
        ᛧfunctorEither = Dict{"map": func(f Any) Any {
            return func(m Any) Any {
                if Is(m, "Left") {
                    return Apply(ꞋLeft(), m.(Dict)["value0"])
                }
                if Is(m, "Right") {
                    return Apply(ꞋRight(), Apply(f, m.(Dict)["value0"]))
                }
                panic("Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0)")
            }
        },}
    })
return ᛧfunctorEither
}


func Ꞌmap() Any {
    return Apply(Data_Functor.Ꞌmap(), ꞋfunctorEither())
}

var ᛌinvariantEither_once Once
var ᛧinvariantEither Any

func ꞋinvariantEither() Any {
    ᛌinvariantEither_once.Do(func() {
        ᛧinvariantEither = Dict{"imap": Apply(Data_Functor_Invariant.ꞋimapF(), ꞋfunctorEither()),}
    })
return ᛧinvariantEither
}


func ꞋfromRightꞌ() Any {
    return func(v Any) Any {
        return func(v1 Any) Any {
            if Is(v1, "Right") {
                return v1.(Dict)["value0"]
            }
            return Apply(v, Data_Unit.Ꞌunit())
        }
    }
}
func ꞋfromRight() Any {
    return func(v Any) Any {
        return func(v1 Any) Any {
            if Is(v1, "Right") {
                return v1.(Dict)["value0"]
            }
            return v
        }
    }
}
func ꞋfromLeftꞌ() Any {
    return func(v Any) Any {
        return func(v1 Any) Any {
            if Is(v1, "Left") {
                return v1.(Dict)["value0"]
            }
            return Apply(v, Data_Unit.Ꞌunit())
        }
    }
}
func ꞋfromLeft() Any {
    return func(v Any) Any {
        return func(v1 Any) Any {
            if Is(v1, "Left") {
                return v1.(Dict)["value0"]
            }
            return v
        }
    }
}

var ᛌextendEither_once Once
var ᛧextendEither Any

func ꞋextendEither() Any {
    ᛌextendEither_once.Do(func() {
        ᛧextendEither = Dict{"extend": func(v Any) Any {
            return func(v1 Any) Any {
                if Is(v1, "Left") {
                    return Apply(ꞋLeft(), v1.(Dict)["value0"])
                }
                return Apply(ꞋRight(), Apply(v, v1))
            }
        }, "Functor0": func(_ Any) Any {
            return ꞋfunctorEither()
        },}
    })
return ᛧextendEither
}


func ꞋeqEither() Any {
    return func(dictEq Any) Any {
        var eq Any = Apply(Data_Eq.Ꞌeq(), dictEq)
        return func(dictEq1 Any) Any {
            var eq1 Any = Apply(Data_Eq.Ꞌeq(), dictEq1)
            return Dict{"eq": func(x Any) Any {
                    return func(y Any) Any {
                        if Is(x, "Left") && Is(y, "Left") {
                            return Apply(eq, x.(Dict)["value0"], y.(Dict)["value0"])
                        }
                        if Is(x, "Right") && Is(y, "Right") {
                            return Apply(eq1, x.(Dict)["value0"], y.(Dict)["value0"])
                        }
                        return false
                    }
                },}
        }
    }
}
func ꞋordEither() Any {
    return func(dictOrd Any) Any {
        var compare Any = Apply(Data_Ord.Ꞌcompare(), dictOrd)
        var eqEither1 Any = Apply(ꞋeqEither(), Apply(dictOrd.(Dict)["Eq0"], Undefined))
        return func(dictOrd1 Any) Any {
            var compare1 Any = Apply(Data_Ord.Ꞌcompare(), dictOrd1)
            var eqEither2 Any = Apply(eqEither1, Apply(dictOrd1.(Dict)["Eq0"], Undefined))
            return Dict{"compare": func(x Any) Any {
                    return func(y Any) Any {
                        if Is(x, "Left") && Is(y, "Left") {
                            return Apply(compare, x.(Dict)["value0"], y.(Dict)["value0"])
                        }
                        if Is(x, "Left") {
                            return Data_Ordering.ꞋLT()
                        }
                        if Is(y, "Left") {
                            return Data_Ordering.ꞋGT()
                        }
                        if Is(x, "Right") && Is(y, "Right") {
                            return Apply(compare1, x.(Dict)["value0"], y.(Dict)["value0"])
                        }
                        panic("Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0)")
                    }
                }, "Eq0": func(_ Any) Any {
                    return eqEither2
                },}
        }
    }
}
func Ꞌeq1Either() Any {
    return func(dictEq Any) Any {
        var eqEither1 Any = Apply(ꞋeqEither(), dictEq)
        return Dict{"eq1": func(dictEq1 Any) Any {
                return Apply(Data_Eq.Ꞌeq(), Apply(eqEither1, dictEq1))
            },}
    }
}
func Ꞌord1Either() Any {
    return func(dictOrd Any) Any {
        var ordEither1 Any = Apply(ꞋordEither(), dictOrd)
        var eq1Either1 Any = Apply(Ꞌeq1Either(), Apply(dictOrd.(Dict)["Eq0"], Undefined))
        return Dict{"compare1": func(dictOrd1 Any) Any {
                return Apply(Data_Ord.Ꞌcompare(), Apply(ordEither1, dictOrd1))
            }, "Eq10": func(_ Any) Any {
                return eq1Either1
            },}
    }
}
func Ꞌeither() Any {
    return func(v Any) Any {
        return func(v1 Any) Any {
            return func(v2 Any) Any {
                if Is(v2, "Left") {
                    return Apply(v, v2.(Dict)["value0"])
                }
                if Is(v2, "Right") {
                    return Apply(v1, v2.(Dict)["value0"])
                }
                panic("Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64)")
            }
        }
    }
}
func Ꞌhush() Any {
    return Apply(Ꞌeither(), Apply(Data_Function.Ꞌconst(), Data_Maybe.ꞋNothing()), Data_Maybe.ꞋJust())
}
func ꞋisLeft() Any {
    return Apply(Ꞌeither(), Apply(Data_Function.Ꞌconst(), true), Apply(Data_Function.Ꞌconst(), false))
}
func ꞋisRight() Any {
    return Apply(Ꞌeither(), Apply(Data_Function.Ꞌconst(), false), Apply(Data_Function.Ꞌconst(), true))
}
func Ꞌchoose() Any {
    return func(dictAlt Any) Any {
        var alt Any = Apply(Control_Alt.Ꞌalt(), dictAlt)
        var map1 Any = Apply(Data_Functor.Ꞌmap(), Apply(dictAlt.(Dict)["Functor0"], Undefined))
        return func(a Any) Any {
            return func(b Any) Any {
                return Apply(alt, Apply(map1, ꞋLeft(), a), Apply(map1, ꞋRight(), b))
            }
        }
    }
}
func ꞋboundedEither() Any {
    return func(dictBounded Any) Any {
        var bottom Any = Apply(Data_Bounded.Ꞌbottom(), dictBounded)
        var ordEither1 Any = Apply(ꞋordEither(), Apply(dictBounded.(Dict)["Ord0"], Undefined))
        return func(dictBounded1 Any) Any {
            var ordEither2 Any = Apply(ordEither1, Apply(dictBounded1.(Dict)["Ord0"], Undefined))
            return Dict{"top": Apply(ꞋRight(), Apply(Data_Bounded.Ꞌtop(), dictBounded1)), "bottom": Apply(ꞋLeft(), bottom), "Ord0": func(_ Any) Any {
                    return ordEither2
                },}
        }
    }
}
func Ꞌblush() Any {
    return Apply(Ꞌeither(), Data_Maybe.ꞋJust(), Apply(Data_Function.Ꞌconst(), Data_Maybe.ꞋNothing()))
}

var ᛌapplyEither_once Once
var ᛧapplyEither Any

func ꞋapplyEither() Any {
    ᛌapplyEither_once.Do(func() {
        ᛧapplyEither = Dict{"apply": func(v Any) Any {
            return func(v1 Any) Any {
                if Is(v, "Left") {
                    return Apply(ꞋLeft(), v.(Dict)["value0"])
                }
                if Is(v, "Right") {
                    return Apply(Ꞌmap(), v.(Dict)["value0"], v1)
                }
                panic("Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30)")
            }
        }, "Functor0": func(_ Any) Any {
            return ꞋfunctorEither()
        },}
    })
return ᛧapplyEither
}


func Ꞌapply() Any {
    return Apply(Control_Apply.Ꞌapply(), ꞋapplyEither())
}

var ᛌbindEither_once Once
var ᛧbindEither Any

func ꞋbindEither() Any {
    ᛌbindEither_once.Do(func() {
        ᛧbindEither = Dict{"bind": Apply(Ꞌeither(), func(e Any) Any {
            return func(v Any) Any {
                return Apply(ꞋLeft(), e)
            }
        }, func(a Any) Any {
            return func(f Any) Any {
                return Apply(f, a)
            }
        }), "Apply0": func(_ Any) Any {
            return ꞋapplyEither()
        },}
    })
return ᛧbindEither
}


func ꞋsemigroupEither() Any {
    return func(dictSemigroup Any) Any {
        var append1 Any = Apply(Data_Semigroup.Ꞌappend(), dictSemigroup)
        return Dict{"append": func(x Any) Any {
                return func(y Any) Any {
                    return Apply(Ꞌapply(), Apply(Ꞌmap(), append1, x), y)
                }
            },}
    }
}

var ᛌapplicativeEither_once Once
var ᛧapplicativeEither Any

func ꞋapplicativeEither() Any {
    ᛌapplicativeEither_once.Do(func() {
        ᛧapplicativeEither = Dict{"pure": ꞋRight(), "Apply0": func(_ Any) Any {
            return ꞋapplyEither()
        },}
    })
return ᛧapplicativeEither
}



var ᛌmonadEither_once Once
var ᛧmonadEither Any

func ꞋmonadEither() Any {
    ᛌmonadEither_once.Do(func() {
        ᛧmonadEither = Dict{"Applicative0": func(_ Any) Any {
            return ꞋapplicativeEither()
        }, "Bind1": func(_ Any) Any {
            return ꞋbindEither()
        },}
    })
return ᛧmonadEither
}



var ᛌaltEither_once Once
var ᛧaltEither Any

func ꞋaltEither() Any {
    ᛌaltEither_once.Do(func() {
        ᛧaltEither = Dict{"alt": func(v Any) Any {
            return func(v1 Any) Any {
                if Is(v, "Left") {
                    return v1
                }
                return v
            }
        }, "Functor0": func(_ Any) Any {
            return ꞋfunctorEither()
        },}
    })
return ᛧaltEither
}





