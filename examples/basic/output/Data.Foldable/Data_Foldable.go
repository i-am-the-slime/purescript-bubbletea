// Code generated by psgo. DO NOT EDIT.

package Data_Foldable

import . "github.com/purescript-native/go-runtime"

import (
	"project.localhost/purescript-native/output/Data.Eq"
	"project.localhost/purescript-native/output/Data.Semiring"
	"project.localhost/purescript-native/output/Control.Semigroupoid"
	"project.localhost/purescript-native/output/Control.Category"
	"project.localhost/purescript-native/output/Data.Ordering"
	"project.localhost/purescript-native/output/Data.Newtype"
	"project.localhost/purescript-native/output/Data.Monoid.Endo"
	"project.localhost/purescript-native/output/Data.Monoid.Dual"
	"project.localhost/purescript-native/output/Data.HeytingAlgebra"
	"project.localhost/purescript-native/output/Data.Maybe"
	"project.localhost/purescript-native/output/Control.Alt"
	"project.localhost/purescript-native/output/Control.Plus"
	"project.localhost/purescript-native/output/Control.Apply"
	"project.localhost/purescript-native/output/Control.Applicative"
	"project.localhost/purescript-native/output/Data.Unit"
	"project.localhost/purescript-native/output/Data.Function"
	"project.localhost/purescript-native/output/Data.Semigroup"
	"project.localhost/purescript-native/output/Data.Monoid"
	"project.localhost/purescript-native/output/Data.Ord"
	"project.localhost/purescript-native/output/Data.Functor.Coproduct"
	"project.localhost/purescript-native/output/Data.Maybe.First"
	"project.localhost/purescript-native/output/Control.Bind"
	"project.localhost/purescript-native/output/Data.Monoid.Disj"
	"project.localhost/purescript-native/output/Data.Monoid.Conj"
)

type _ = Any

func Ꞌeq() Any {
    return Apply(Data_Eq.Ꞌeq(), Data_Eq.ꞋeqInt())
}
func Ꞌadd() Any {
    return Apply(Data_Semiring.Ꞌadd(), Data_Semiring.ꞋsemiringInt())
}
func Ꞌcompose() Any {
    return Apply(Control_Semigroupoid.Ꞌcompose(), Control_Semigroupoid.ꞋsemigroupoidFn())
}
func Ꞌidentity() Any {
    return Apply(Control_Category.Ꞌidentity(), Control_Category.ꞋcategoryFn())
}
func Ꞌeq1() Any {
    return Apply(Data_Eq.Ꞌeq(), Data_Ordering.ꞋeqOrdering())
}
func Ꞌunwrap() Any {
    return Apply(Data_Newtype.Ꞌunwrap(), Undefined)
}
func ꞋmonoidEndo() Any {
    return Apply(Data_Monoid_Endo.ꞋmonoidEndo(), Control_Category.ꞋcategoryFn())
}
func ꞋmonoidDual() Any {
    return Apply(Data_Monoid_Dual.ꞋmonoidDual(), ꞋmonoidEndo())
}
func ꞋalaF() Any {
    return Apply(Data_Newtype.ꞋalaF(), Undefined, Undefined, Undefined, Undefined)
}
func Ꞌnot() Any {
    return Apply(Data_HeytingAlgebra.Ꞌnot(), Data_HeytingAlgebra.ꞋheytingAlgebraBoolean())
}
func ꞋFoldable_ṩDict() Any {
    return func(x Any) Any {
        return x
    }
}
func Ꞌfoldr() Any {
    return func(dict Any) Any {
        return dict.(Dict)["foldr"]
    }
}
func Ꞌindexr() Any {
    return func(dictFoldable Any) Any {
        var foldr2 Any = Apply(Ꞌfoldr(), dictFoldable)
        return func(idx Any) Any {
            var ˉgo Any = func(a Any) Any {
                return func(cursor Any) Any {
                    if Is(cursor.(Dict)["elem"], "Just") {
                        return cursor
                    }
                    var ṩ8 Any = Apply(Ꞌeq(), cursor.(Dict)["pos"], idx)
                    if ṩ8 == true {
                        return Dict{"elem": Apply(Data_Maybe.ꞋJust(), a), "pos": cursor.(Dict)["pos"],}
                    }
                    return Dict{"pos": Apply(Ꞌadd(), cursor.(Dict)["pos"], 1), "elem": cursor.(Dict)["elem"],}
                }
            }
            return Apply(Ꞌcompose(), func(v Any) Any {
                return v.(Dict)["elem"]
            }, Apply(foldr2, ˉgo, Dict{"elem": Data_Maybe.ꞋNothing(), "pos": 0,}))
        }
    }
}
func Ꞌnull() Any {
    return func(dictFoldable Any) Any {
        return Apply(Ꞌfoldr(), dictFoldable, func(v Any) Any {
            return func(v1 Any) Any {
                return false
            }
        }, true)
    }
}
func ꞋoneOf() Any {
    return func(dictFoldable Any) Any {
        var foldr2 Any = Apply(Ꞌfoldr(), dictFoldable)
        return func(dictPlus Any) Any {
            return Apply(foldr2, Apply(Control_Alt.Ꞌalt(), Apply(dictPlus.(Dict)["Alt0"], Undefined)), Apply(Control_Plus.Ꞌempty(), dictPlus))
        }
    }
}
func ꞋoneOfMap() Any {
    return func(dictFoldable Any) Any {
        var foldr2 Any = Apply(Ꞌfoldr(), dictFoldable)
        return func(dictPlus Any) Any {
            var alt Any = Apply(Control_Alt.Ꞌalt(), Apply(dictPlus.(Dict)["Alt0"], Undefined))
            var empty Any = Apply(Control_Plus.Ꞌempty(), dictPlus)
            return func(f Any) Any {
                return Apply(foldr2, Apply(Ꞌcompose(), alt, f), empty)
            }
        }
    }
}
func Ꞌtraverse_() Any {
    return func(dictApplicative Any) Any {
        var applySecond Any = Apply(Control_Apply.ꞋapplySecond(), Apply(dictApplicative.(Dict)["Apply0"], Undefined))
        var pure Any = Apply(Control_Applicative.Ꞌpure(), dictApplicative)
        return func(dictFoldable Any) Any {
            var foldr2 Any = Apply(Ꞌfoldr(), dictFoldable)
            return func(f Any) Any {
                return Apply(foldr2, Apply(Ꞌcompose(), applySecond, f), Apply(pure, Data_Unit.Ꞌunit()))
            }
        }
    }
}
func Ꞌfor_() Any {
    return func(dictApplicative Any) Any {
        var traverse_1 Any = Apply(Ꞌtraverse_(), dictApplicative)
        return func(dictFoldable Any) Any {
            return Apply(Data_Function.Ꞌflip(), Apply(traverse_1, dictFoldable))
        }
    }
}
func Ꞌsequence_() Any {
    return func(dictApplicative Any) Any {
        var traverse_1 Any = Apply(Ꞌtraverse_(), dictApplicative)
        return func(dictFoldable Any) Any {
            return Apply(traverse_1, dictFoldable, Ꞌidentity())
        }
    }
}
func Ꞌfoldl() Any {
    return func(dict Any) Any {
        return dict.(Dict)["foldl"]
    }
}
func Ꞌindexl() Any {
    return func(dictFoldable Any) Any {
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        return func(idx Any) Any {
            var ˉgo Any = func(cursor Any) Any {
                return func(a Any) Any {
                    if Is(cursor.(Dict)["elem"], "Just") {
                        return cursor
                    }
                    var ṩ12 Any = Apply(Ꞌeq(), cursor.(Dict)["pos"], idx)
                    if ṩ12 == true {
                        return Dict{"elem": Apply(Data_Maybe.ꞋJust(), a), "pos": cursor.(Dict)["pos"],}
                    }
                    return Dict{"pos": Apply(Ꞌadd(), cursor.(Dict)["pos"], 1), "elem": cursor.(Dict)["elem"],}
                }
            }
            return Apply(Ꞌcompose(), func(v Any) Any {
                return v.(Dict)["elem"]
            }, Apply(foldl2, ˉgo, Dict{"elem": Data_Maybe.ꞋNothing(), "pos": 0,}))
        }
    }
}
func Ꞌintercalate() Any {
    return func(dictFoldable Any) Any {
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        return func(dictMonoid Any) Any {
            var append Any = Apply(Data_Semigroup.Ꞌappend(), Apply(dictMonoid.(Dict)["Semigroup0"], Undefined))
            var mempty Any = Apply(Data_Monoid.Ꞌmempty(), dictMonoid)
            return func(sep Any) Any {
                return func(xs Any) Any {
                    var ˉgo Any = func(v Any) Any {
                        return func(v1 Any) Any {
                            if v.(Dict)["init"] == true {
                                return Dict{"init": false, "acc": v1,}
                            }
                            return Dict{"init": false, "acc": Apply(append, v.(Dict)["acc"], Apply(append, sep, v1)),}
                        }
                    }
                    return Apply(foldl2, ˉgo, Dict{"init": true, "acc": mempty,}, xs).(Dict)["acc"]
                }
            }
        }
    }
}
func Ꞌlength() Any {
    return func(dictFoldable Any) Any {
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        return func(dictSemiring Any) Any {
            var add1 Any = Apply(Data_Semiring.Ꞌadd(), dictSemiring)
            var one Any = Apply(Data_Semiring.Ꞌone(), dictSemiring)
            return Apply(foldl2, func(c Any) Any {
                return func(v Any) Any {
                    return Apply(add1, one, c)
                }
            }, Apply(Data_Semiring.Ꞌzero(), dictSemiring))
        }
    }
}
func ꞋmaximumBy() Any {
    return func(dictFoldable Any) Any {
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        return func(cmp Any) Any {
            var maxꞌ Any = func(v Any) Any {
                return func(v1 Any) Any {
                    if Is(v, "Nothing") {
                        return Apply(Data_Maybe.ꞋJust(), v1)
                    }
                    if Is(v, "Just") {
                        return Apply(Data_Maybe.ꞋJust(), Run(func() Any {
                            var ṩ19 Any = Apply(Ꞌeq1(), Apply(cmp, v.(Dict)["value0"], v1), Data_Ordering.ꞋGT())
                            if ṩ19 == true {
                                return v.(Dict)["value0"]
                            }
                            return v1
                        }))
                    }
                    panic("Failed pattern match at Data.Foldable (line 441, column 3 - line 441, column 27)")
                }
            }
            return Apply(foldl2, maxꞌ, Data_Maybe.ꞋNothing())
        }
    }
}
func Ꞌmaximum() Any {
    return func(dictOrd Any) Any {
        var compare Any = Apply(Data_Ord.Ꞌcompare(), dictOrd)
        return func(dictFoldable Any) Any {
            return Apply(ꞋmaximumBy(), dictFoldable, compare)
        }
    }
}
func ꞋminimumBy() Any {
    return func(dictFoldable Any) Any {
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        return func(cmp Any) Any {
            var minꞌ Any = func(v Any) Any {
                return func(v1 Any) Any {
                    if Is(v, "Nothing") {
                        return Apply(Data_Maybe.ꞋJust(), v1)
                    }
                    if Is(v, "Just") {
                        return Apply(Data_Maybe.ꞋJust(), Run(func() Any {
                            var ṩ23 Any = Apply(Ꞌeq1(), Apply(cmp, v.(Dict)["value0"], v1), Data_Ordering.ꞋLT())
                            if ṩ23 == true {
                                return v.(Dict)["value0"]
                            }
                            return v1
                        }))
                    }
                    panic("Failed pattern match at Data.Foldable (line 454, column 3 - line 454, column 27)")
                }
            }
            return Apply(foldl2, minꞌ, Data_Maybe.ꞋNothing())
        }
    }
}
func Ꞌminimum() Any {
    return func(dictOrd Any) Any {
        var compare Any = Apply(Data_Ord.Ꞌcompare(), dictOrd)
        return func(dictFoldable Any) Any {
            return Apply(ꞋminimumBy(), dictFoldable, compare)
        }
    }
}
func Ꞌproduct() Any {
    return func(dictFoldable Any) Any {
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        return func(dictSemiring Any) Any {
            return Apply(foldl2, Apply(Data_Semiring.Ꞌmul(), dictSemiring), Apply(Data_Semiring.Ꞌone(), dictSemiring))
        }
    }
}
func Ꞌsum() Any {
    return func(dictFoldable Any) Any {
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        return func(dictSemiring Any) Any {
            return Apply(foldl2, Apply(Data_Semiring.Ꞌadd(), dictSemiring), Apply(Data_Semiring.Ꞌzero(), dictSemiring))
        }
    }
}

var ᛌfoldableTuple_once Once
var ᛧfoldableTuple Any

func ꞋfoldableTuple() Any {
    ᛌfoldableTuple_once.Do(func() {
        ᛧfoldableTuple = Dict{"foldr": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, v.(Dict)["value1"], z)
                }
            }
        }, "foldl": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, z, v.(Dict)["value1"])
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            return func(f Any) Any {
                return func(v Any) Any {
                    return Apply(f, v.(Dict)["value1"])
                }
            }
        },}
    })
return ᛧfoldableTuple
}



var ᛌfoldableMultiplicative_once Once
var ᛧfoldableMultiplicative Any

func ꞋfoldableMultiplicative() Any {
    ᛌfoldableMultiplicative_once.Do(func() {
        ᛧfoldableMultiplicative = Dict{"foldr": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, v, z)
                }
            }
        }, "foldl": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, z, v)
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            return func(f Any) Any {
                return func(v Any) Any {
                    return Apply(f, v)
                }
            }
        },}
    })
return ᛧfoldableMultiplicative
}



var ᛌfoldableMaybe_once Once
var ᛧfoldableMaybe Any

func ꞋfoldableMaybe() Any {
    ᛌfoldableMaybe_once.Do(func() {
        ᛧfoldableMaybe = Dict{"foldr": func(v Any) Any {
            return func(v1 Any) Any {
                return func(v2 Any) Any {
                    if Is(v2, "Nothing") {
                        return v1
                    }
                    if Is(v2, "Just") {
                        return Apply(v, v2.(Dict)["value0"], v1)
                    }
                    panic("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27)")
                }
            }
        }, "foldl": func(v Any) Any {
            return func(v1 Any) Any {
                return func(v2 Any) Any {
                    if Is(v2, "Nothing") {
                        return v1
                    }
                    if Is(v2, "Just") {
                        return Apply(v, v1, v2.(Dict)["value0"])
                    }
                    panic("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27)")
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            var mempty Any = Apply(Data_Monoid.Ꞌmempty(), dictMonoid)
            return func(v Any) Any {
                return func(v1 Any) Any {
                    if Is(v1, "Nothing") {
                        return mempty
                    }
                    if Is(v1, "Just") {
                        return Apply(v, v1.(Dict)["value0"])
                    }
                    panic("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27)")
                }
            }
        },}
    })
return ᛧfoldableMaybe
}


func Ꞌfoldr1() Any {
    return Apply(Ꞌfoldr(), ꞋfoldableMaybe())
}
func Ꞌfoldl1() Any {
    return Apply(Ꞌfoldl(), ꞋfoldableMaybe())
}

var ᛌfoldableIdentity_once Once
var ᛧfoldableIdentity Any

func ꞋfoldableIdentity() Any {
    ᛌfoldableIdentity_once.Do(func() {
        ᛧfoldableIdentity = Dict{"foldr": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, v, z)
                }
            }
        }, "foldl": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, z, v)
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            return func(f Any) Any {
                return func(v Any) Any {
                    return Apply(f, v)
                }
            }
        },}
    })
return ᛧfoldableIdentity
}



var ᛌfoldableEither_once Once
var ᛧfoldableEither Any

func ꞋfoldableEither() Any {
    ᛌfoldableEither_once.Do(func() {
        ᛧfoldableEither = Dict{"foldr": func(v Any) Any {
            return func(v1 Any) Any {
                return func(v2 Any) Any {
                    if Is(v2, "Left") {
                        return v1
                    }
                    if Is(v2, "Right") {
                        return Apply(v, v2.(Dict)["value0"], v1)
                    }
                    panic("Failed pattern match at Data.Foldable (line 181, column 1 - line 187, column 28)")
                }
            }
        }, "foldl": func(v Any) Any {
            return func(v1 Any) Any {
                return func(v2 Any) Any {
                    if Is(v2, "Left") {
                        return v1
                    }
                    if Is(v2, "Right") {
                        return Apply(v, v1, v2.(Dict)["value0"])
                    }
                    panic("Failed pattern match at Data.Foldable (line 181, column 1 - line 187, column 28)")
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            var mempty Any = Apply(Data_Monoid.Ꞌmempty(), dictMonoid)
            return func(v Any) Any {
                return func(v1 Any) Any {
                    if Is(v1, "Left") {
                        return mempty
                    }
                    if Is(v1, "Right") {
                        return Apply(v, v1.(Dict)["value0"])
                    }
                    panic("Failed pattern match at Data.Foldable (line 181, column 1 - line 187, column 28)")
                }
            }
        },}
    })
return ᛧfoldableEither
}



var ᛌfoldableDual_once Once
var ᛧfoldableDual Any

func ꞋfoldableDual() Any {
    ᛌfoldableDual_once.Do(func() {
        ᛧfoldableDual = Dict{"foldr": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, v, z)
                }
            }
        }, "foldl": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, z, v)
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            return func(f Any) Any {
                return func(v Any) Any {
                    return Apply(f, v)
                }
            }
        },}
    })
return ᛧfoldableDual
}



var ᛌfoldableDisj_once Once
var ᛧfoldableDisj Any

func ꞋfoldableDisj() Any {
    ᛌfoldableDisj_once.Do(func() {
        ᛧfoldableDisj = Dict{"foldr": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, v, z)
                }
            }
        }, "foldl": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, z, v)
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            return func(f Any) Any {
                return func(v Any) Any {
                    return Apply(f, v)
                }
            }
        },}
    })
return ᛧfoldableDisj
}



var ᛌfoldableConst_once Once
var ᛧfoldableConst Any

func ꞋfoldableConst() Any {
    ᛌfoldableConst_once.Do(func() {
        ᛧfoldableConst = Dict{"foldr": func(v Any) Any {
            return func(z Any) Any {
                return func(v1 Any) Any {
                    return z
                }
            }
        }, "foldl": func(v Any) Any {
            return func(z Any) Any {
                return func(v1 Any) Any {
                    return z
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            var mempty Any = Apply(Data_Monoid.Ꞌmempty(), dictMonoid)
            return func(v Any) Any {
                return func(v1 Any) Any {
                    return mempty
                }
            }
        },}
    })
return ᛧfoldableConst
}



var ᛌfoldableConj_once Once
var ᛧfoldableConj Any

func ꞋfoldableConj() Any {
    ᛌfoldableConj_once.Do(func() {
        ᛧfoldableConj = Dict{"foldr": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, v, z)
                }
            }
        }, "foldl": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, z, v)
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            return func(f Any) Any {
                return func(v Any) Any {
                    return Apply(f, v)
                }
            }
        },}
    })
return ᛧfoldableConj
}



var ᛌfoldableAdditive_once Once
var ᛧfoldableAdditive Any

func ꞋfoldableAdditive() Any {
    ᛌfoldableAdditive_once.Do(func() {
        ᛧfoldableAdditive = Dict{"foldr": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, v, z)
                }
            }
        }, "foldl": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(f, z, v)
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            return func(f Any) Any {
                return func(v Any) Any {
                    return Apply(f, v)
                }
            }
        },}
    })
return ᛧfoldableAdditive
}


func ꞋfoldMapDefaultR() Any {
    return func(dictFoldable Any) Any {
        var foldr2 Any = Apply(Ꞌfoldr(), dictFoldable)
        return func(dictMonoid Any) Any {
            var append Any = Apply(Data_Semigroup.Ꞌappend(), Apply(dictMonoid.(Dict)["Semigroup0"], Undefined))
            var mempty Any = Apply(Data_Monoid.Ꞌmempty(), dictMonoid)
            return func(f Any) Any {
                return Apply(foldr2, func(x Any) Any {
                    return func(acc Any) Any {
                        return Apply(append, Apply(f, x), acc)
                    }
                }, mempty)
            }
        }
    }
}

var ᛌfoldableArray_once Once
var ᛧfoldableArray Any

func ꞋfoldableArray() Any {
    ᛌfoldableArray_once.Do(func() {
        ᛧfoldableArray = Dict{"foldr": ꞋfoldrArray(), "foldl": ꞋfoldlArray(), "foldMap": func(dictMonoid Any) Any {
            return Apply(ꞋfoldMapDefaultR(), ꞋfoldableArray(), dictMonoid)
        },}
    })
return ᛧfoldableArray
}


func ꞋfoldMapDefaultL() Any {
    return func(dictFoldable Any) Any {
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        return func(dictMonoid Any) Any {
            var append Any = Apply(Data_Semigroup.Ꞌappend(), Apply(dictMonoid.(Dict)["Semigroup0"], Undefined))
            var mempty Any = Apply(Data_Monoid.Ꞌmempty(), dictMonoid)
            return func(f Any) Any {
                return Apply(foldl2, func(acc Any) Any {
                    return func(x Any) Any {
                        return Apply(append, acc, Apply(f, x))
                    }
                }, mempty)
            }
        }
    }
}
func ꞋfoldMap() Any {
    return func(dict Any) Any {
        return dict.(Dict)["foldMap"]
    }
}
func ꞋfoldMap1() Any {
    return Apply(ꞋfoldMap(), ꞋfoldableMaybe())
}
func ꞋfoldableApp() Any {
    return func(dictFoldable Any) Any {
        var foldr2 Any = Apply(Ꞌfoldr(), dictFoldable)
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        var foldMap2 Any = Apply(ꞋfoldMap(), dictFoldable)
        return Dict{"foldr": func(f Any) Any {
                return func(i Any) Any {
                    return func(v Any) Any {
                        return Apply(foldr2, f, i, v)
                    }
                }
            }, "foldl": func(f Any) Any {
                return func(i Any) Any {
                    return func(v Any) Any {
                        return Apply(foldl2, f, i, v)
                    }
                }
            }, "foldMap": func(dictMonoid Any) Any {
                var foldMap3 Any = Apply(foldMap2, dictMonoid)
                return func(f Any) Any {
                    return func(v Any) Any {
                        return Apply(foldMap3, f, v)
                    }
                }
            },}
    }
}
func ꞋfoldableCompose() Any {
    return func(dictFoldable Any) Any {
        var foldr2 Any = Apply(Ꞌfoldr(), dictFoldable)
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        var foldMap2 Any = Apply(ꞋfoldMap(), dictFoldable)
        return func(dictFoldable1 Any) Any {
            var foldr3 Any = Apply(Ꞌfoldr(), dictFoldable1)
            var foldl3 Any = Apply(Ꞌfoldl(), dictFoldable1)
            var foldMap3 Any = Apply(ꞋfoldMap(), dictFoldable1)
            return Dict{"foldr": func(f Any) Any {
                    return func(i Any) Any {
                        return func(v Any) Any {
                            return Apply(foldr2, Apply(Data_Function.Ꞌflip(), Apply(foldr3, f)), i, v)
                        }
                    }
                }, "foldl": func(f Any) Any {
                    return func(i Any) Any {
                        return func(v Any) Any {
                            return Apply(foldl2, Apply(foldl3, f), i, v)
                        }
                    }
                }, "foldMap": func(dictMonoid Any) Any {
                    var foldMap4 Any = Apply(foldMap2, dictMonoid)
                    var foldMap5 Any = Apply(foldMap3, dictMonoid)
                    return func(f Any) Any {
                        return func(v Any) Any {
                            return Apply(foldMap4, Apply(foldMap5, f), v)
                        }
                    }
                },}
        }
    }
}
func ꞋfoldableCoproduct() Any {
    return func(dictFoldable Any) Any {
        var foldr2 Any = Apply(Ꞌfoldr(), dictFoldable)
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        var foldMap2 Any = Apply(ꞋfoldMap(), dictFoldable)
        return func(dictFoldable1 Any) Any {
            var foldr3 Any = Apply(Ꞌfoldr(), dictFoldable1)
            var foldl3 Any = Apply(Ꞌfoldl(), dictFoldable1)
            var foldMap3 Any = Apply(ꞋfoldMap(), dictFoldable1)
            return Dict{"foldr": func(f Any) Any {
                    return func(z Any) Any {
                        return Apply(Data_Functor_Coproduct.Ꞌcoproduct(), Apply(foldr2, f, z), Apply(foldr3, f, z))
                    }
                }, "foldl": func(f Any) Any {
                    return func(z Any) Any {
                        return Apply(Data_Functor_Coproduct.Ꞌcoproduct(), Apply(foldl2, f, z), Apply(foldl3, f, z))
                    }
                }, "foldMap": func(dictMonoid Any) Any {
                    var foldMap4 Any = Apply(foldMap2, dictMonoid)
                    var foldMap5 Any = Apply(foldMap3, dictMonoid)
                    return func(f Any) Any {
                        return Apply(Data_Functor_Coproduct.Ꞌcoproduct(), Apply(foldMap4, f), Apply(foldMap5, f))
                    }
                },}
        }
    }
}

var ᛌfoldableFirst_once Once
var ᛧfoldableFirst Any

func ꞋfoldableFirst() Any {
    ᛌfoldableFirst_once.Do(func() {
        ᛧfoldableFirst = Dict{"foldr": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(Ꞌfoldr1(), f, z, v)
                }
            }
        }, "foldl": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(Ꞌfoldl1(), f, z, v)
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            var foldMap2 Any = Apply(ꞋfoldMap1(), dictMonoid)
            return func(f Any) Any {
                return func(v Any) Any {
                    return Apply(foldMap2, f, v)
                }
            }
        },}
    })
return ᛧfoldableFirst
}



var ᛌfoldableLast_once Once
var ᛧfoldableLast Any

func ꞋfoldableLast() Any {
    ᛌfoldableLast_once.Do(func() {
        ᛧfoldableLast = Dict{"foldr": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(Ꞌfoldr1(), f, z, v)
                }
            }
        }, "foldl": func(f Any) Any {
            return func(z Any) Any {
                return func(v Any) Any {
                    return Apply(Ꞌfoldl1(), f, z, v)
                }
            }
        }, "foldMap": func(dictMonoid Any) Any {
            var foldMap2 Any = Apply(ꞋfoldMap1(), dictMonoid)
            return func(f Any) Any {
                return func(v Any) Any {
                    return Apply(foldMap2, f, v)
                }
            }
        },}
    })
return ᛧfoldableLast
}


func ꞋfoldableProduct() Any {
    return func(dictFoldable Any) Any {
        var foldr2 Any = Apply(Ꞌfoldr(), dictFoldable)
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        var foldMap2 Any = Apply(ꞋfoldMap(), dictFoldable)
        return func(dictFoldable1 Any) Any {
            var foldr3 Any = Apply(Ꞌfoldr(), dictFoldable1)
            var foldl3 Any = Apply(Ꞌfoldl(), dictFoldable1)
            var foldMap3 Any = Apply(ꞋfoldMap(), dictFoldable1)
            return Dict{"foldr": func(f Any) Any {
                    return func(z Any) Any {
                        return func(v Any) Any {
                            return Apply(foldr2, f, Apply(foldr3, f, z, v.(Dict)["value1"]), v.(Dict)["value0"])
                        }
                    }
                }, "foldl": func(f Any) Any {
                    return func(z Any) Any {
                        return func(v Any) Any {
                            return Apply(foldl3, f, Apply(foldl2, f, z, v.(Dict)["value0"]), v.(Dict)["value1"])
                        }
                    }
                }, "foldMap": func(dictMonoid Any) Any {
                    var append Any = Apply(Data_Semigroup.Ꞌappend(), Apply(dictMonoid.(Dict)["Semigroup0"], Undefined))
                    var foldMap4 Any = Apply(foldMap2, dictMonoid)
                    var foldMap5 Any = Apply(foldMap3, dictMonoid)
                    return func(f Any) Any {
                        return func(v Any) Any {
                            return Apply(append, Apply(foldMap4, f, v.(Dict)["value0"]), Apply(foldMap5, f, v.(Dict)["value1"]))
                        }
                    }
                },}
        }
    }
}
func ꞋfoldlDefault() Any {
    return func(dictFoldable Any) Any {
        var foldMap2 Any = Apply(ꞋfoldMap(), dictFoldable, ꞋmonoidDual())
        return func(c Any) Any {
            return func(u Any) Any {
                return func(xs Any) Any {
                    return Apply(Ꞌunwrap(), Apply(Ꞌunwrap(), Apply(foldMap2, Apply(Ꞌcompose(), Data_Monoid_Dual.ꞋDual(), Apply(Ꞌcompose(), Data_Monoid_Endo.ꞋEndo(), Apply(Data_Function.Ꞌflip(), c))), xs)), u)
                }
            }
        }
    }
}
func ꞋfoldrDefault() Any {
    return func(dictFoldable Any) Any {
        var foldMap2 Any = Apply(ꞋfoldMap(), dictFoldable, ꞋmonoidEndo())
        return func(c Any) Any {
            return func(u Any) Any {
                return func(xs Any) Any {
                    return Apply(Ꞌunwrap(), Apply(foldMap2, Apply(Ꞌcompose(), Data_Monoid_Endo.ꞋEndo(), c), xs), u)
                }
            }
        }
    }
}
func Ꞌlookup() Any {
    return func(dictFoldable Any) Any {
        var foldMap2 Any = Apply(ꞋfoldMap(), dictFoldable, Data_Maybe_First.ꞋmonoidFirst())
        return func(dictEq Any) Any {
            var eq2 Any = Apply(Data_Eq.Ꞌeq(), dictEq)
            return func(a Any) Any {
                return Apply(Ꞌcompose(), Ꞌunwrap(), Apply(foldMap2, func(v Any) Any {
                    var ṩ160 Any = Apply(eq2, a, v.(Dict)["value0"])
                    if ṩ160 == true {
                        return Apply(Data_Maybe.ꞋJust(), v.(Dict)["value1"])
                    }
                    return Data_Maybe.ꞋNothing()
                }))
            }
        }
    }
}
func ꞋsurroundMap() Any {
    return func(dictFoldable Any) Any {
        var foldMap2 Any = Apply(ꞋfoldMap(), dictFoldable, ꞋmonoidEndo())
        return func(dictSemigroup Any) Any {
            var append Any = Apply(Data_Semigroup.Ꞌappend(), dictSemigroup)
            return func(d Any) Any {
                return func(t Any) Any {
                    return func(f Any) Any {
                        var joined Any = func(a Any) Any {
                            return func(m Any) Any {
                                return Apply(append, d, Apply(append, Apply(t, a), m))
                            }
                        }
                        return Apply(Ꞌunwrap(), Apply(foldMap2, joined, f), d)
                    }
                }
            }
        }
    }
}
func Ꞌsurround() Any {
    return func(dictFoldable Any) Any {
        var surroundMap1 Any = Apply(ꞋsurroundMap(), dictFoldable)
        return func(dictSemigroup Any) Any {
            var surroundMap2 Any = Apply(surroundMap1, dictSemigroup)
            return func(d Any) Any {
                return Apply(surroundMap2, d, Ꞌidentity())
            }
        }
    }
}
func ꞋfoldM() Any {
    return func(dictFoldable Any) Any {
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        return func(dictMonad Any) Any {
            var bind Any = Apply(Control_Bind.Ꞌbind(), Apply(dictMonad.(Dict)["Bind1"], Undefined))
            var pure Any = Apply(Control_Applicative.Ꞌpure(), Apply(dictMonad.(Dict)["Applicative0"], Undefined))
            return func(f Any) Any {
                return func(b0 Any) Any {
                    return Apply(foldl2, func(b Any) Any {
                        return func(a Any) Any {
                            return Apply(bind, b, Apply(Data_Function.Ꞌflip(), f, a))
                        }
                    }, Apply(pure, b0))
                }
            }
        }
    }
}
func Ꞌfold() Any {
    return func(dictFoldable Any) Any {
        var foldMap2 Any = Apply(ꞋfoldMap(), dictFoldable)
        return func(dictMonoid Any) Any {
            return Apply(foldMap2, dictMonoid, Ꞌidentity())
        }
    }
}
func ꞋfindMap() Any {
    return func(dictFoldable Any) Any {
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        return func(p Any) Any {
            var ˉgo Any = func(v Any) Any {
                return func(v1 Any) Any {
                    if Is(v, "Nothing") {
                        return Apply(p, v1)
                    }
                    return v
                }
            }
            return Apply(foldl2, ˉgo, Data_Maybe.ꞋNothing())
        }
    }
}
func Ꞌfind() Any {
    return func(dictFoldable Any) Any {
        var foldl2 Any = Apply(Ꞌfoldl(), dictFoldable)
        return func(p Any) Any {
            var ˉgo Any = func(v Any) Any {
                return func(v1 Any) Any {
                    if Is(v, "Nothing") && Apply(p, v1) == true {
                        return Apply(Data_Maybe.ꞋJust(), v1)
                    }
                    return v
                }
            }
            return Apply(foldl2, ˉgo, Data_Maybe.ꞋNothing())
        }
    }
}
func Ꞌany() Any {
    return func(dictFoldable Any) Any {
        var foldMap2 Any = Apply(ꞋfoldMap(), dictFoldable)
        return func(dictHeytingAlgebra Any) Any {
            return Apply(ꞋalaF(), Data_Monoid_Disj.ꞋDisj(), Apply(foldMap2, Apply(Data_Monoid_Disj.ꞋmonoidDisj(), dictHeytingAlgebra)))
        }
    }
}
func Ꞌelem() Any {
    return func(dictFoldable Any) Any {
        var any1 Any = Apply(Ꞌany(), dictFoldable, Data_HeytingAlgebra.ꞋheytingAlgebraBoolean())
        return func(dictEq Any) Any {
            return Apply(Ꞌcompose(), any1, Apply(Data_Eq.Ꞌeq(), dictEq))
        }
    }
}
func ꞋnotElem() Any {
    return func(dictFoldable Any) Any {
        var elem1 Any = Apply(Ꞌelem(), dictFoldable)
        return func(dictEq Any) Any {
            var elem2 Any = Apply(elem1, dictEq)
            return func(x Any) Any {
                return Apply(Ꞌcompose(), Ꞌnot(), Apply(elem2, x))
            }
        }
    }
}
func Ꞌor() Any {
    return func(dictFoldable Any) Any {
        var any1 Any = Apply(Ꞌany(), dictFoldable)
        return func(dictHeytingAlgebra Any) Any {
            return Apply(any1, dictHeytingAlgebra, Ꞌidentity())
        }
    }
}
func Ꞌall() Any {
    return func(dictFoldable Any) Any {
        var foldMap2 Any = Apply(ꞋfoldMap(), dictFoldable)
        return func(dictHeytingAlgebra Any) Any {
            return Apply(ꞋalaF(), Data_Monoid_Conj.ꞋConj(), Apply(foldMap2, Apply(Data_Monoid_Conj.ꞋmonoidConj(), dictHeytingAlgebra)))
        }
    }
}
func Ꞌand() Any {
    return func(dictFoldable Any) Any {
        var all1 Any = Apply(Ꞌall(), dictFoldable)
        return func(dictHeytingAlgebra Any) Any {
            return Apply(all1, dictHeytingAlgebra, Ꞌidentity())
        }
    }
}


// Foreign values

var foreign = Foreign("Data.Foldable")

var ᛌfoldrArray_once Once
var ᛧfoldrArray Any

func ꞋfoldrArray() Any { 
    ᛌfoldrArray_once.Do(func() {
        ᛧfoldrArray = Get(foreign, "foldrArray")
    })
    return ᛧfoldrArray
}

var ᛌfoldlArray_once Once
var ᛧfoldlArray Any

func ꞋfoldlArray() Any { 
    ᛌfoldlArray_once.Do(func() {
        ᛧfoldlArray = Get(foreign, "foldlArray")
    })
    return ᛧfoldlArray
}


