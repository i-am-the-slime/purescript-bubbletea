// Code generated by psgo. DO NOT EDIT.

package Data_Profunctor_Split

import . "github.com/purescript-native/go-runtime"

import (
	"project.localhost/purescript-native/output/Control.Semigroupoid"
	"project.localhost/purescript-native/output/Control.Category"
	"project.localhost/purescript-native/output/Data.Exists"
	"project.localhost/purescript-native/output/Data.Function"
	"project.localhost/purescript-native/output/Data.Functor.Invariant"
)

type _ = Any

func Ꞌcompose() Any {
    return Apply(Control_Semigroupoid.Ꞌcompose(), Control_Semigroupoid.ꞋsemigroupoidFn())
}
func Ꞌidentity() Any {
    return Apply(Control_Category.Ꞌidentity(), Control_Category.ꞋcategoryFn())
}
func ꞋSplitF() Any {
    return func(value0 Any) Any {
        return func(value1 Any) Any {
            return func(value2 Any) Any {
                return Dict{"SplitF": true, "value0": value0, "value1": value1, "value2": value2,}
            }
        }
    }
}
func ꞋSplit() Any {
    return func(x Any) Any {
        return x
    }
}
func ꞋunSplit() Any {
    return func(f Any) Any {
        return func(v Any) Any {
            return Apply(Data_Exists.ꞋrunExists(), func(v1 Any) Any {
                return Apply(f, v1.(Dict)["value0"], v1.(Dict)["value1"], v1.(Dict)["value2"])
            }, v)
        }
    }
}
func Ꞌsplit() Any {
    return func(f Any) Any {
        return func(g Any) Any {
            return func(fx Any) Any {
                return Apply(Data_Exists.ꞋmkExists(), Apply(ꞋSplitF(), f, g, fx))
            }
        }
    }
}

var ᛌprofunctorSplit_once Once
var ᛧprofunctorSplit Any

func ꞋprofunctorSplit() Any {
    ᛌprofunctorSplit_once.Do(func() {
        ᛧprofunctorSplit = Dict{"dimap": func(f Any) Any {
            return func(g Any) Any {
                return Apply(ꞋunSplit(), func(h Any) Any {
                    return func(i Any) Any {
                        return Apply(Ꞌsplit(), Apply(Ꞌcompose(), h, f), Apply(Ꞌcompose(), g, i))
                    }
                })
            }
        },}
    })
return ᛧprofunctorSplit
}


func ꞋlowerSplit() Any {
    return func(dictInvariant Any) Any {
        return Apply(ꞋunSplit(), Apply(Data_Function.Ꞌflip(), Apply(Data_Functor_Invariant.Ꞌimap(), dictInvariant)))
    }
}
func ꞋliftSplit() Any {
    return Apply(Ꞌsplit(), Ꞌidentity(), Ꞌidentity())
}
func ꞋhoistSplit() Any {
    return func(nat Any) Any {
        return Apply(ꞋunSplit(), func(f Any) Any {
            return func(g Any) Any {
                return Apply(Ꞌcompose(), Apply(Ꞌsplit(), f, g), nat)
            }
        })
    }
}

var ᛌfunctorSplit_once Once
var ᛧfunctorSplit Any

func ꞋfunctorSplit() Any {
    ᛌfunctorSplit_once.Do(func() {
        ᛧfunctorSplit = Dict{"map": func(f Any) Any {
            return Apply(ꞋunSplit(), func(g Any) Any {
                return func(h Any) Any {
                    return func(fx Any) Any {
                        return Apply(Ꞌsplit(), g, Apply(Ꞌcompose(), f, h), fx)
                    }
                }
            })
        },}
    })
return ᛧfunctorSplit
}





