// Code generated by psgo. DO NOT EDIT.

package Data_Eq_Generic

import . "github.com/purescript-native/go-runtime"

import (
	"project.localhost/purescript-native/output/Data.HeytingAlgebra"
	"project.localhost/purescript-native/output/Data.Eq"
	"project.localhost/purescript-native/output/Data.Generic.Rep"
)

type _ = Any

func Ꞌconj() Any {
    return Apply(Data_HeytingAlgebra.Ꞌconj(), Data_HeytingAlgebra.ꞋheytingAlgebraBoolean())
}
func ꞋGenericEq_ṩDict() Any {
    return func(x Any) Any {
        return x
    }
}

var ᛌgenericEqNoConstructors_once Once
var ᛧgenericEqNoConstructors Any

func ꞋgenericEqNoConstructors() Any {
    ᛌgenericEqNoConstructors_once.Do(func() {
        ᛧgenericEqNoConstructors = Dict{"genericEq'": func(v Any) Any {
            return func(v1 Any) Any {
                return true
            }
        },}
    })
return ᛧgenericEqNoConstructors
}



var ᛌgenericEqNoArguments_once Once
var ᛧgenericEqNoArguments Any

func ꞋgenericEqNoArguments() Any {
    ᛌgenericEqNoArguments_once.Do(func() {
        ᛧgenericEqNoArguments = Dict{"genericEq'": func(v Any) Any {
            return func(v1 Any) Any {
                return true
            }
        },}
    })
return ᛧgenericEqNoArguments
}


func ꞋgenericEqArgument() Any {
    return func(dictEq Any) Any {
        var eq Any = Apply(Data_Eq.Ꞌeq(), dictEq)
        return Dict{"genericEq'": func(v Any) Any {
                return func(v1 Any) Any {
                    return Apply(eq, v, v1)
                }
            },}
    }
}
func ꞋgenericEqꞌ() Any {
    return func(dict Any) Any {
        return dict.(Dict)["genericEq'"]
    }
}
func ꞋgenericEqConstructor() Any {
    return func(dictGenericEq Any) Any {
        var genericEqꞌ1 Any = Apply(ꞋgenericEqꞌ(), dictGenericEq)
        return Dict{"genericEq'": func(v Any) Any {
                return func(v1 Any) Any {
                    return Apply(genericEqꞌ1, v, v1)
                }
            },}
    }
}
func ꞋgenericEqProduct() Any {
    return func(dictGenericEq Any) Any {
        var genericEqꞌ1 Any = Apply(ꞋgenericEqꞌ(), dictGenericEq)
        return func(dictGenericEq1 Any) Any {
            var genericEqꞌ2 Any = Apply(ꞋgenericEqꞌ(), dictGenericEq1)
            return Dict{"genericEq'": func(v Any) Any {
                    return func(v1 Any) Any {
                        return Apply(Ꞌconj(), Apply(genericEqꞌ1, v.(Dict)["value0"], v1.(Dict)["value0"]), Apply(genericEqꞌ2, v.(Dict)["value1"], v1.(Dict)["value1"]))
                    }
                },}
        }
    }
}
func ꞋgenericEqSum() Any {
    return func(dictGenericEq Any) Any {
        var genericEqꞌ1 Any = Apply(ꞋgenericEqꞌ(), dictGenericEq)
        return func(dictGenericEq1 Any) Any {
            var genericEqꞌ2 Any = Apply(ꞋgenericEqꞌ(), dictGenericEq1)
            return Dict{"genericEq'": func(v Any) Any {
                    return func(v1 Any) Any {
                        if Is(v, "Inl") && Is(v1, "Inl") {
                            return Apply(genericEqꞌ1, v.(Dict)["value0"], v1.(Dict)["value0"])
                        }
                        if Is(v, "Inr") && Is(v1, "Inr") {
                            return Apply(genericEqꞌ2, v.(Dict)["value0"], v1.(Dict)["value0"])
                        }
                        return false
                    }
                },}
        }
    }
}
func ꞋgenericEq() Any {
    return func(dictGeneric Any) Any {
        var from Any = Apply(Data_Generic_Rep.Ꞌfrom(), dictGeneric)
        return func(dictGenericEq Any) Any {
            var genericEqꞌ1 Any = Apply(ꞋgenericEqꞌ(), dictGenericEq)
            return func(x Any) Any {
                return func(y Any) Any {
                    return Apply(genericEqꞌ1, Apply(from, x), Apply(from, y))
                }
            }
        }
    }
}



